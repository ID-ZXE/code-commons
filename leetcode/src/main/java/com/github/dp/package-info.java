/**
 * @author hangs.zhang
 * @date 2020/03/24 22:15
 * *****************
 */
package com.github.dp;

// 动态规划 文章
// https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486904&idx=1&sn=099d5560ab25c0163349dff0c7f51490&chksm=fa0e6239cd79eb2fe6e831d7debba60aa906721d592b8766a944ef88bf91bf82568c20d71891&scene=21#wechat_redirect
// https://www.cxyxiaowu.com/7012.html
// https://www.cxyxiaowu.com/7006.html
// https://www.cxyxiaowu.com/7046.html

//动态规划算法 dp
//用一句解释动态规划就是: 记住你之前得到的答案
//1. 问题拆解
//2. 状态定义
//3. 递归方程推导
//4. 实现

// 斐波拉契数列/青蛙跳台阶/fib
// dp[0] = 0, dp[1] = 1
// dp[i] = dp[i-1] + dp[i-2]

// 最大子数组和,leetcode 53
// dp[i]中存储了0到当前位置的最大和,dp[i] = Math.max(dp[i-1], 0) + arr[i]

// 最长上升子序列的长度,leetcode 300
// 每个dp填充为1,因为每个单独的元素都是一个上升子序列
// dp[i]中存储了0到当前位置的最长子序列长度,在arr[0~i-1] < arr[i]d的情况下:dp[i] = Math.max(dp[0~i-1]+1, dp[i])

// 粉刷房子问题 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。
// 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。
// 例如，costs[0][0]表示第 0 号房子粉刷成红色的成本花费；costs[1][2]表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。
// 此时一维dp已经不能解决问题了,需要二维,除了位置之外,还需要把价格考虑进去
// dp[i][k]位置存储的数据是i位置使用第k中颜色的最小花销
// dp[i][k] = Math.min(dp[i-1][l], dp[i-1][r]) + costs[i][k],其中l!=k,r!=k

// 打家劫舍问题,leetcode 198
// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
// 获取最大收益
// dp[i]存储当前位置能获得的最大收益
// dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1])